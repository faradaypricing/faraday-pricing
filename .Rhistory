jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
names(print.df)[names(print.df) == 'bh.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'bh.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
```
\newpage
```{r, echo=FALSE,warning=FALSE,results='asis', message =FALSE, comment= NA}
task <- tsk.df$Task[9]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
names(print.df)[names(print.df) == 'bh.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'bh.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
```
\newpage
```{r, echo=FALSE,warning=FALSE,results='asis', message =FALSE, comment= NA}
task <- tsk.df$Task[10]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
names(print.df)[names(print.df) == 'bh.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'bh.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
```
\newpage
```{r, echo=FALSE,warning=FALSE,results='asis', message =FALSE, comment= NA}
task <- tsk.df$Task[11]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
names(print.df)[names(print.df) == 'bh.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'bh.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
```
\newpage
```{r, echo=FALSE,warning=FALSE,results='asis', message =FALSE, comment= NA}
task <- tsk.df$Task[12]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
names(print.df)[names(print.df) == 'bh.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'bh.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
```
setwd("H:/Admin/2015 Planning")
task <- tsk.df$Task[11]
task <- tsk.df$Task[12]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
View(df)
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
print.df <- dcast(data = jm.df, jm.df$Order + jm.df$Sub.task ~ jm.df$Month, sum)
names(print.df)[names(print.df) == 'jm.df$Sub.task'] <- 'Sub-task'
names(print.df)[names(print.df) == 'jm.df$Order'] <- 'Order'
print.df <- print.df[order(print.df$Order),]
kable(print.df, row.names=F)
cat("The time split for BH is as follows")
bh.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "BH",]
print.df <- dcast(data = bh.df, bh.df$Order + bh.df$Sub.task  ~ bh.df$Month, sum)
View(tsk.df)
task <- tsk.df$Task[4]
cat(paste("##", task, sep = ' '),"\n\n")
cat("The list of tasks is as follows")
df <- summarise(group_by(subset(melt.tasks,Task == task), Order, Sub.task ), Time = sum(Time))
kable(df[order(df$Order),],col.names = c("Order", "Sub-task", "Time(weeks)"))
cat("The time split for JM is as follows","\n\n")
jm.df <- melt.tasks[melt.tasks$Task == task & melt.tasks$Person == "JM",]
View(df)
View(jm.df)
View(melt.tasks)
View(df)
tasks <-read.csv("2015_tasks.csv")
tasks$Task <- as.character(tasks$Task)
tasks$Sub.task <- as.character(tasks$Sub.task)
View(tasks)
split_into_columns <- function(char_vector, num_rows){
vec <- as.character(char_vector)
if(length(vec) < num_rows){
num_rows = length(vec)
}
ncols <- ceiling(length(vec) / num_rows)
retVal <- do.call("cbind", lapply(1:ncols, function(n){
start = (n-1)*num_rows + 1
end = min(n*num_rows, length(vec))
r <- vec[start:end]
if(length(r) < num_rows){
r <- c(r, rep("",num_rows - length(r)))
}
return(r)
}))
colnames(retVal) <- paste("col.", 1:ncols, sep="")
return(retVal)
}
devtools::load_all(".")
library(Faraday.Pricing)
library(Faraday.Pricing)
library(Faraday.Pricing)
library(actuar)
dunif
library(actuar)
dgenpareto
actuar_do_dpq
actuar:::actuar_do_dpq
weights <- c(0.6,0.4)
means <- c(5,8)
value <- 10
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
survival <- sum(weights * dexp(x = value, rate = 1/means))
survival
dmixedexp <- function(weights, means, value){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
survival <- sum(weights * dexp(x = value, rate = 1/means))
return(1- survival)
}
dmixedexp(weights,means,value)
dmixedexp(weights,means,c(8,9,10))
dunif(x = c(0.8))
dunif(x = c(1))
dunif(x = c(.4))
dmixedexp <- function(weights, means, value){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- sum(weights/means * exp(-value/means)
return(retVal)
}
dmixedexp <- function(weights, means, value){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- sum(weights/means * exp(-value/means)
return(retVal)
}
dmixedexp <- function(weights, means, value){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- sum(weights/means * exp(-value/means))
return(retVal)
}
dmixedexp(weights,means,value)
dmixedexp <- function(weights, means, value){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- sum(weights * exp(-value/means))
return(retVal)
}
dmixedexp(weights,means,value)
punif(q = c(0.7,0.8,0;.9))
punif(q = c(0.7,0.8,0.9))
dmixedexp <- function(weights, means, q){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- sapply(q, function(value){
sum(weights/means * exp(-value/means))
})
return(retVal)
}
dmixedexp(weights,means,c(8,9,10))
pmixedexp <- function(weights, means, q){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
if(sum(weights) != 1){
stop("Weights must sum to 1")
}
retVal <- retVal <- sapply(q, function(value){
sum(weights * exp(-value/means))
})
retVal <- 1 - retVal
return(retVal)
}
rmixedexp <- function(n, weights, means){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
weights_adj <- weights / sum(weights)
samps <- sample(x = 1:length(weights), size = n, replace = T, prob = weights_adj)
retVal <- sapply(samps, function(index){
r <- rexp(n = 1, rate = 1/means[index])
})
return(retVal)
}
rmixedexp(100,weights,means)
install.packages("rootSolve")
library(rootSolve)
lower.tail = TRUE
log.p = FALSE
x <- rootSolve::uniroot.all(pmixedexp, weights = weights, means = means, lower.tail = lower.tail, log.p = log.p, interval = c(0,Inf))
x <- rootSolve::uniroot.all(pmixedexp, weights = weights, means = means, lower.tail = lower.tail, log.p = log.p, interval = c(0,1E10))
x <- rootSolve::uniroot.all(f = pmixedexp, interval = c(0,1E10), weights = weights, means = means, lower.tail = lower.tail, log.p = log.p)
x <- rootSolve::uniroot.all(f = pmixedexp, interval = c(0,1E10), weights = weights, means = means)
pmixedexp <- function(q, weights, means, lower.tail = TRUE, log.p = FALSE){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
weights_adj <- weights / sum(weights)
retVal <- sapply(q, function(value){
sum(weights_adj * exp(-value/means))
})
if(lower.tail){
retVal <- 1 - retVal
}
if(log.p){
retVal <- log(retVal)
}
return(retVal)
}
x <- rootSolve::uniroot.all(f = pmixedexp, interval = c(0,1E10), weights = weights, means = means, lower.tail = lower.tail, log.p = log.p)
func <- function(x){
pmixedexp(x, weights = weights, means = means, lower.tail = lower.tail, log.p = log.p) - p
}
x <- rootSolve::uniroot.all(f = func, interval = c(0,1E10))
p=0.8
func <- function(x){
pmixedexp(x, weights = weights, means = means, lower.tail = lower.tail, log.p = log.p)
}
x <- rootSolve::uniroot.all(f = func, interval = c(0,1E10))
func <- function(x){
pmixedexp(x, weights = weights, means = means, lower.tail = lower.tail, log.p = log.p) - p
}
x <- rootSolve::uniroot.all(f = func, interval = c(0,1E10))
means
p=0.99
x <- rootSolve::uniroot.all(f = func, interval = c(0,1E10))
runif
library(Faraday.Pricing)
library(actuar)
levexp
levexp(limit = c(2,4), rate = 0.5)
levmixedexp <- function(limit, weights, means){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
weights_adj <- weights / sum(weights)
lambdas <- 1/means
retVal <- sapply(limit, function(l){
lev <- sapply(a:length(weights), function(i){
x <- weights_adj[i] * levexp(l, lambdas[i], order = 1)
})
return(sum(lev))
})
return(retVal)
}
levmixedexp(limit = c(10,20), weights = (1,3,4), means = c(4,6,10))
levmixedexp(limit = c(10,20), weights = c(1,3,4), means = c(4,6,10))
levmixedexp <- function(limit, weights, means){
if(length(weights) != length(means)){
stop("The weights and means vectors cannot have different lengths")
}
weights_adj <- weights / sum(weights)
lambdas <- 1/means
retVal <- sapply(limit, function(l){
lev <- sapply(1:length(weights), function(i){
x <- weights_adj[i] * levexp(l, lambdas[i], order = 1)
})
return(sum(lev))
})
return(retVal)
}
levmixedexp(limit = c(10,20), weights = c(1,3,4), means = c(4,6,10))
library(Faraday.Pricing)
install.package("TTR")
install.packages("TTR")
library(TTR)
kkt <- function(lambda, data, weights, means){
count <- length(data)
weights_adj <- weights / sum(weights)
data_sum <- sapply(data, function(d){
sum = 0
for(i in 1:length(weights)){
sum = sum + weights[i] /means[i] * exp(- d / means[i])
}
})
results <- sapply(value, function(v){
retVal <- 0
for(i in 1:length(data)){
temp = lambda * exp(- data[i] * lambda)
temp = retVal / data_sum[i]
retVal = retVal + temp
}
return(retVal)
})
return(results)
}
g <- length(group_counts)
kkt_grouped <- function(lambda, group_boundaries, group_counts, weights, means){
weights_adj <- weights / sum(weights)
g <- length(group_counts)
results <- sapply(value, function(v){
retVal <- 0
## first group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (1 - exp(- group_boundaries[1] / means[i]))
}
retVal = retVal + group_counts[1] * (1 - exp( - v * group_boundaries[1])) / sum
## middle groups
for(k in 2:(g-1)){
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[k-1] / means[i]) - exp(- group_boundaries[k] / means[i]))
}
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
temp = retVal / sum
retVal = retVal + temp
}
## last group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[g-1] / means[i]))
}
retVal = retVal + group_counts[g] * exp( - v * group_boundaries[g-1]) / sum
return(retVal)
})
return(results)
}
group_boundaries <- c(2500,7500,12500,17500,22500,32500,47500,67500,87500,125000,175000,225000,325000,475000,675000,1000000)
group_counts <- c(58,61,37,36,22,30,19,15,11,18,7,7,6,2,2,2,3)
weights <- 1
means <- 51,190
values <- c(1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000,30000,40000,50000,60000,70000,80000,90000,100000,200000,300000,400000,500000,600000,700000,800000,900000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000)
means <- 51190
values <- c(1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000,30000,40000,50000,60000,70000,80000,90000,100000,200000,300000,400000,500000,600000,700000,800000,900000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000)
kkt_grouped(lambda = 1/values, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
lambda = 1/values
weights_adj <- weights / sum(weights)
g <- length(group_counts)
kkt_grouped <- function(lambda, group_boundaries, group_counts, weights, means){
weights_adj <- weights / sum(weights)
g <- length(group_counts)
results <- sapply(lambda, function(v){
retVal <- 0
## first group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (1 - exp(- group_boundaries[1] / means[i]))
}
retVal = retVal + group_counts[1] * (1 - exp( - v * group_boundaries[1])) / sum
## middle groups
for(k in 2:(g-1)){
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[k-1] / means[i]) - exp(- group_boundaries[k] / means[i]))
}
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
temp = retVal / sum
retVal = retVal + temp
}
## last group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[g-1] / means[i]))
}
retVal = retVal + group_counts[g] * exp( - v * group_boundaries[g-1]) / sum
return(retVal)
})
return(results)
}
kkt_grouped(lambda = 1/values, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
v <- lambda[1]
v
retVal <- 0
## first group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (1 - exp(- group_boundaries[1] / means[i]))
}
retVal = retVal + group_counts[1] * (1 - exp( - v * group_boundaries[1])) / sum
for(k in 2:(g-1)){
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[k-1] / means[i]) - exp(- group_boundaries[k] / means[i]))
}
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
temp = retVal / sum
retVal = retVal + temp
}
k=2
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[k-1] / means[i]) - exp(- group_boundaries[k] / means[i]))
}
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
temp = retVal / sum
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
kkt_grouped <- function(lambda, group_boundaries, group_counts, weights, means){
weights_adj <- weights / sum(weights)
g <- length(group_counts)
results <- sapply(lambda, function(v){
retVal <- 0
## first group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (1 - exp(- group_boundaries[1] / means[i]))
}
retVal = retVal + group_counts[1] * (1 - exp( - v * group_boundaries[1])) / sum
## middle groups
for(k in 2:(g-1)){
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[k-1] / means[i]) - exp(- group_boundaries[k] / means[i]))
}
temp = group_counts[k] * (exp( - v * group_boundaries[k-1]) - exp( - v * group_boundaries[k])) / sum
retVal = retVal + temp
}
## last group
sum <- 0
for(i in 1:length(weights)){
sum = sum + weights[i] * (exp(- group_boundaries[g-1] / means[i]))
}
retVal = retVal + group_counts[g] * exp( - v * group_boundaries[g-1]) / sum
return(retVal)
})
return(results)
}
kkt_grouped(lambda = 1/values, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
values <- c(1000,2000,3000,4000,5000,6000,7000,8000,9000,10000,20000,30000,40000,50000, 51190,60000,70000,80000,90000,100000,200000,300000,400000,500000,600000,700000,800000,900000,1000000,2000000,3000000,4000000,5000000,6000000,7000000,8000000,9000000,10000000)
kkt_grouped(lambda = 1/values, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
weights <- c(0.0526, 0.5999, 0.3102, 0.0373)
means <- c(0, 12336,77922,712302)
kkt_grouped(lambda = 1/values, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
v <- c(means, values)
kkt_grouped(lambda = 1/v, group_boundaries = group_boundaries, group_counts = group_counts, weights = weights, means = means)
