{
    "contents" : "\n\n\n#' Calculate the following probabilities for a nil claim at a certain development period:\n#' - the probability that it will be nil at the next development\n#' - the probability that it will be nil at the maximum development period\n#' \nnil_claim_survival_probabilities <- function(claim.data, ref, dev_name, value_name ,group = NULL){\n  \n  # copy data\n  data = claim.data\n  \n  # set up single fake group if data isn't grouped\n  if(is.null(group)){\n    group.col = 1\n  } else{\n    group.col = data[,group]\n  }\n  data = data.frame(dev_name=data[,dev_name], ref=data[,ref], group = group.col, value_name = data[,value_name])\n  data$nil <- ifelse(data$value_name > 0 , 0 , 1)\n  \n  # drop claim value_name column\n  data <- data[,colnames(data) != \"value_name\"]\n  \n  #match next \n  data.next = data\n  data.next$dev_name <- data[[dev_name]] - 1\n  \n  cols <- colnames(data)[which(colnames(data) != \"nil\")]\n  data <- merge(data, data.next, by = cols)\n  \n  # sum counts to enable probability estimate\n  data <- data %>% select(dev_name, group, nil.x, nil.y) %>% group_by( group, dev_name) %>% summarise_each(funs(sum))\n  data$inc.prob <- 1\n  data$inc.prob <- ifelse(data$nil.x==0, 1, data$nil.y / data$nil.x)\n  \n  # cumulative probability assuming independence between periods\n  data = data %>% arrange(desc(dev_name))\n  data= data %>% mutate(cum.prob = cumprod(inc.prob))\n  \n  if(is.null(group)){\n    retVal = data.frame(dev_name = data$dev_name, inc.prob=data$inc.prob, cum.prob=data$cum.prob)\n    retVal = retVal %>% arrange(dev_name)\n    colnames(retVal) <- c(dev_name,\"inc.prob\",\"cum.prob\")\n  } else {\n    retVal = data.frame(group = data$group, dev_name = data$dev_name, inc.prob=data$inc.prob, cum.prob=data$cum.prob)\n    retVal = retVal %>% arrange(group,dev_name)\n    colnames(retVal) <- c(group,dev_name,\"inc.prob\",\"cum.prob\")    \n  }\n  retVal \n}\n\nNilClaimsSurvivalProbs <- function(x, y, group = NULL){\n  \n  # copy data\n  data = sign(as.numeric(x))\n  \n  # set up single fake group if data isn't grouped\n  if(is.null(group)){\n    group.col = 1\n  } else{\n    group.col = data[,group]\n  }\n  data = data.frame(dev_name=data[,dev_name], ref=data[,ref], group = group.col, value_name = data[,value_name])\n  data$nil <- ifelse(data$value_name > 0 , 0 , 1)\n  \n  # drop claim value_name column\n  data <- data[,colnames(data) != \"value_name\"]\n  \n  #match next \n  data.next = data\n  data.next$dev_name <- data[[dev_name]] - 1\n  \n  cols <- colnames(data)[which(colnames(data) != \"nil\")]\n  data <- merge(data, data.next, by = cols)\n  \n  # sum counts to enable probability estimate\n  data <- data %>% select(dev_name, group, nil.x, nil.y) %>% group_by( group, dev_name) %>% summarise_each(funs(sum))\n  data$inc.prob <- 1\n  data$inc.prob <- ifelse(data$nil.x==0, 1, data$nil.y / data$nil.x)\n  \n  # cumulative probability assuming independence between periods\n  data = data %>% arrange(desc(dev_name))\n  data= data %>% mutate(cum.prob = cumprod(inc.prob))\n  \n  if(is.null(group)){\n    retVal = data.frame(dev_name = data$dev_name, inc.prob=data$inc.prob, cum.prob=data$cum.prob)\n    retVal = retVal %>% arrange(dev_name)\n    colnames(retVal) <- c(dev_name,\"inc.prob\",\"cum.prob\")\n  } else {\n    retVal = data.frame(group = data$group, dev_name = data$dev_name, inc.prob=data$inc.prob, cum.prob=data$cum.prob)\n    retVal = retVal %>% arrange(group,dev_name)\n    colnames(retVal) <- c(group,dev_name,\"inc.prob\",\"cum.prob\")    \n  }\n  retVal \n}",
    "created" : 1422891510265.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "7|98|50|0|\n",
    "hash" : "2507386319",
    "id" : "492D9D51",
    "lastKnownWriteTime" : 1428576735,
    "path" : "C:/Projects/git/faraday-pricing/R/nil_claims.R",
    "project_path" : "R/nil_claims.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}